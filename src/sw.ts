/// <reference lib="webworker" />

import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { CacheFirst, NetworkFirst } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';

declare const self: ServiceWorkerGlobalScope;

// Precache all the assets generated by the build process.
precacheAndRoute(self.__WB_MANIFEST);

// Basic caching for app assets
registerRoute(
  ({ request }) => request.destination === 'script' || request.destination === 'style',
  new NetworkFirst()
);

registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days
      }),
    ],
  })
);

// This is where we will handle the tour download logic
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'DOWNLOAD_TOUR') {
    const { tourId, urls, authToken } = event.data.payload;
    const cacheName = `tour-${tourId}`;

    event.waitUntil(
      caches.open(cacheName).then((cache) => {
        console.log(`[SW] Caching tour ${tourId}`);
        const requests = urls.map((url: string) => {
          // Create a new Request object to add the Authorization header
          const headers = new Headers();
          if (authToken) {
            headers.append('Authorization', `Bearer ${authToken}`);
          }
          const request = new Request(url, { headers });
          return cache.add(request);
        });
        return Promise.all(requests)
          .then(() => {
            console.log(`[SW] Tour ${tourId} cached successfully.`);
            // Notify the client that the download is complete
            event.source?.postMessage({ type: 'DOWNLOAD_COMPLETE', payload: { tourId } });
          })
          .catch((error) => {
            console.error(`[SW] Caching failed for tour ${tourId}:`, error);
          });
      })
    );
  }
});

// Intercept fetch requests to serve from cache if available
self.addEventListener('fetch', (event) => {
  const requestUrl = new URL(event.request.url);
  
  // Check if the request is for an asset within a tour cache
  const cacheNamePrefix = 'tour-';
  if (requestUrl.protocol === 'https:' && event.request.method === 'GET') {
    event.respondWith(
      caches.keys().then((cacheNames) => {
        const tourCacheName = cacheNames.find(name => name.startsWith(cacheNamePrefix));
        if (tourCacheName) {
          return caches.open(tourCacheName).then((cache) => {
            return cache.match(event.request).then((cachedResponse) => {
              if (cachedResponse) {
                console.log('[SW] Serving from tour cache:', event.request.url);
                return cachedResponse;
              }
              // If not in our specific tour cache, fall back to network
              return fetch(event.request);
            });
          });
        }
        // If not a tour asset, just fetch normally
        return fetch(event.request);
      })
    );
  }
});
